# Лабораторна робота №4
**Дисципліна:** Операційні системи  
**Тема:** “Команди Linux для управління процесами”  
**Виконали:** Глядченко, Козуб 

## Мета роботи
- Отримання практичних навиків роботи з командною оболонкою Bash.
- Знайомство з базовими командами для управління процесами.

---

## Попередня підготовка

### Словник базових термінів

*   **Process:** An instance of a program that is being executed.
*   **PID (Process ID):** A unique identification number assigned to a running process.
*   **PPID (Parent Process ID):** The PID of the process that started the current process.
*   **Terminal (TTY):** A command-line interface or the device file associated with it, through which a user interacts with the system.
*   **Signal:** A software interrupt delivered to a process to notify it that an event has occurred (e.g., interrupt, terminate).
*   **Parent Process:** A process that has created one or more child processes.
*   **Child Process:** A process created by another process (the parent).
*   **Background Process:** A process that runs independently of the shell, allowing the user to continue issuing commands in the same terminal.
*   **Scheduler:** A component of the OS kernel that decides which process runs next, for how long, and in what order.

---

### Відповіді на питання попередньої підготовки

#### 1. Які команди для моніторингу стану процесів ви знаєте. Як переглянути їх можливі параметри?
Існує декілька команд для моніторингу процесів. Найпоширеніші з них — `ps` та `top`.
*   **`ps` (Process Status):** Надає "знімок" поточних процесів. Щоб переглянути її можливі параметри, можна використати команду перегляду інструкції: `man ps`. У терміналі також можна використати `ps --help` для короткого підсумку.
*   **`top`:** Надає динамічне відображення запущених процесів у реальному часі. Для перегляду його параметрів та інтерактивних команд використовуйте `man top` або натисніть 'h', поки команда `top` виконується.
*   **`htop`:** Інтерактивний переглядач процесів (більш зручний, ніж `top`). Переглянути опції можна за допомогою `man htop` або натиснувши F1 всередині програми.
*   **`pgrep`:** Шукає процеси на основі назви та інших атрибутів. Параметри можна перевірити за допомогою `man pgrep`.

#### 2. Чи може команда ps у реальному часі відслідковувати стан процесів?
Ні, команда `ps` не може відслідковувати процеси в реальному часі. Вона надає **статичний знімок** процесів, які виконувалися в момент виконання команди. Для динамічного моніторингу в реальному часі слід використовувати команди на зразок `top` або `htop`.

#### 3. За якими параметрами можливе сортування процесів в команді top? Як переключатись між ними?
За замовчуванням `top` сортує процеси за стовпцем `%CPU`. Можна сортувати за різними іншими полями.
*   **Можливі параметри сортування включають:**
    *   `%CPU`: Використання процесора.
    *   `%MEM`: Використання пам'яті (RES).
    *   `TIME+`: Загальний використаний час CPU.
    *   `PID`: Ідентифікатор процесу.
    *   `NI`: Значення nice.
*   **Як переключатися між ними:**
    1.  Поки `top` виконується, натисніть клавішу `F` або `Shift + f`. Відкриється екран керування полями.
    2.  За допомогою клавіш зі стрілками перейдіть до стовпця, за яким потрібно сортувати (наприклад, `%MEM`).
    3.  Натисніть `s` або `d` (клавіша може відрізнятися; зазвичай 's' використовується для сортування), щоб вибрати цей стовпець як поле сортування.
    4.  Натисніть `q` або `Esc`, щоб повернутися до головного вікна `top`, яке тепер буде відсортовано за вибраним вами полем.

#### 4. Які команди для завершення роботи процесів ви знаєте?
Існує дві основні команди для завершення (або надсилання сигналів) процесам:
*   **`kill`:** Ця команда надсилає сигнал процесу на основі його **ідентифікатора процесу (PID)**.
    *   Базове використання: `kill <PID>` (надсилає сигнал SIGTERM — просить процес завершитися коректно).
    *   Примусове завершення: `kill -9 <PID>` або `kill -KILL <PID>` (надсилає сигнал SIGKILL — безумовно завершує процес).
*   **`killall`:** Ця команда надсилає сигнал усім процесам, які виконуються з певною **назвою команди**.
    *   Базове використання: `killall <назва_процесу>` (наприклад, `killall firefox`).
    *   Як і з `kill`, можна надсилати різні сигнали: `killall -9 <назва_процесу>`.
---

## Хід роботи

### 1. Початкова робота в CLI-режимі

Після входу в ОС Linux та запуску терміналу було виконано ряд команд для дослідження базових механізмів роботи з процесами.

Для ознайомлення з віртуальною файловою системою `/proc` було виконано команду `ls -la /proc | head -20`. У виведеному списку видно числові каталоги, які відповідають ID запущених процесів, а також файли з інформацією про систему (`cpuinfo`, `meminfo`).

> **[СКРІНШОТ 1: Вивід команди `ls -la /proc | head -20`]**  
> ![Скріншот 1](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/1.png)

Далі було досліджено інформацію про поточні сеанси користувачів. Команда `who` вивела список активних сеансів. Більш детальну інформацію надала команда `w`.

> **[СКРІНШОТ 2: Вивід команд `who` та `w`]**  
> ![Скріншот 2](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/2.png)

Для демонстрації роботи сигналів було запущено процес `ping 8.8.8.8`. Після отримання кількох відповідей натиснуто `Ctrl + C` (`SIGINT`), що завершило процес з виведенням статистики.

> **[СКРІНШОТ 3: Процес `ping` після переривання `Ctrl + C`]**  
> ![Скріншот 3](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/3.png)

Потім `ping` було запущено знову і призупинено комбінацією `Ctrl + Z` (`SIGTSTP`). Команда `jobs` підтвердила статус "Stopped".

> **[СКРІНШОТ 4: Стан "Stopped" для процесу `ping` після `Ctrl + Z`]**  
> ![Скріншот 4](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/4.png)

Для керування призупиненим процесом використано команди `bg` та `fg`. Команда `bg %1` відновила виконання пінгу у фоновому режимі. `jobs` підтвердила статус "Running". Після цього `fg %1` повернула процес на передній план, звідки його було завершено `Ctrl + C`.

> **[СКРІНШОТ 5: Вивід `jobs` після виконання `bg %1`]**  
> ![Скріншот 5](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/5.png)

###  Відповіді на питання:

       **Як вивести вміст директорії /proc? Де вона знаходиться та для чого призначена? Охарактеризуйте інформацію про її вміст?**
        Вміст директорії `/proc` можна вивести командою `ls /proc`. Це віртуальна файлова система, яка знаходиться в оперативній пам'яті (RAM) і не містить реальних файлів. Вона призначена для надання інтерфейсу до структур даних ядра, дозволяючи отримувати інформацію про систему та процеси в реальному часі. Її вміст включає каталоги з номерами PID (які містять інформацію про кожен запущений процес), а також файли з інформацією про апаратне забезпечення (`/proc/cpuinfo`), пам'ять (`/proc/meminfo`), версію ядра (`/proc/version`) та багато іншого.
      **Як вивести інформацію про поточні сеанси користувачів. Якою командою це можна зробити?**
        Інформацію про поточні сеанси користувачів можна вивести командою `who`. Вона показує, хто увійшов в систему, з якого терміналу та час входу. Також можна використати команду `w`, яка показує додаткову інформацію, таку як навантаження на систему та поточну команду користувача.
       **Які дії можна зробити в терміналі за допомогою комбінацій Ctrl + C, Ctrl + D та Ctrl + Z?**
        *   `Ctrl + C`: Надсилає сигнал SIGINT (переривання) поточному процесу, що виконується на передньому плані, зазвичай завершуючи його.
        *   `Ctrl + D`: Надсилає символ кінця файлу (EOF). Якщо виконується у порожньому рядку, він завершує поточну оболонку (shell) або програму, яка очікує введення (наприклад, `cat` без аргументів).
        *   `Ctrl + Z`: Призупиняє виконання поточного процесу на передньому плані та переміщує його у фоновий режим (у стан "зупинено"). Потім його можна відновити командами `fg` або `bg`.
       **Чим відрізняється фоновий процес від звичайного. Де вони використовуються?**
        Звичайний (або передньоплановий) процес запускається в терміналі та блокує його, поки не завершиться. Користувач не може вводити нові команди, доки цей процес не закінчить роботу або не буде призупинений.
        Фоновий процес виконується незалежно від терміналу. Після його запуску термінал знову готовий до введення нових команд. Вони використовуються для виконання тривалих завдань або запуску сервісів, які не потребують постійної взаємодії з користувачем, дозволяючи продовжувати роботу в тому ж самому вікні терміналу.
       **Опишіть наступні команди та поясніть що вони виконують – команда jobs, bg, fg.**
        *   `jobs`: Відображає список усіх завдань (процесів), запущених з поточного терміналу, показуючи їх статус (наприклад, "Running", "Stopped") та номер завдання.
        *   `bg` (background): Відновлює виконання призупиненого завдання у фоновому режимі. Якщо вказати номер завдання (наприклад, `bg %1`), відновить саме його.
        *   `fg` (foreground): Повертає фонове або призупинене завдання на передній план. Наприклад, `fg %1` поверне завдання з номером 1.
       **Якою командою можна переглянути інформацію про запущені в системи фонові процеси та задачі?**
        Для перегляду фонових завдань, що належать поточному терміналу, використовується команда `jobs`. Для перегляду *всіх* процесів у системі (включно з фоновими), використовуються команди `ps` або `top`.
       **Як призупинити фоновий процес, як його потім відновити та при необхідності перезапустити?**
        Безпосередньо призупинити вже запущений фоновий процес командою складно. Зазвичай його спочатку повертають на передній план командою `fg`, а потім призупиняють комбінацією `Ctrl+Z`. Після цього його можна відновити:
        *   На передньому плані: `fg %<номер_завдання>`.
        *   У фоновому режимі: `bg %<номер_завдання>`.
        "Перезапустити" процес можна, завершивши його (наприклад, `kill %<номер_завдання>`) і запустивши знову.

### 3. Практична робота з процесами

Наступним етапом стало дослідження спеціалізованих команд для моніторингу та управління процесами.

Було запущено команду `top`. На екрані відобразився інтерактивний інтерфейс з інформацією про час роботи системи, середнє навантаження та список найактивніших процесів.

> **[СКРІНШОТ 6: Загальний вигляд інтерфейсу команди `top`]**  
> ![Скріншот 6](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/6.png)

Виконання `top` було призупинено `Ctrl + Z`. Команда `jobs` підтвердила статус "Stopped".

> **[СКРІНШОТ 7: Вивід `jobs` із завданням `top` у стані "Stopped"]**  
> ![Скріншот 7](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/7.png)

Після призупинення `top` було виконано серію команд `ps` для отримання різноманітної інформації про процеси. Всі команди було об'єднано в одному скріншоті для демонстрації різних форматів виводу:

- `ps -ef | head -15` — повний список всіх процесів з розширеним форматом.
- `ps aux | head -15` — всі процеси з інформацією про використання CPU та пам'яті.
- `ps -u $(whoami)` — процеси поточного користувача.
- `ps -C bash` — процеси, пов'язані з оболонкою Bash.
- `ps -ef --forest | head -25` — ієрархічна структура процесів (дерево).

> **[СКРІНШОТ 8: Вивід різних варіантів команди `ps`]**  
> ![Скріншот 8](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/8.png)

Після ознайомлення зі статичними знімками `ps` було продовжено роботу з призупиненим `top`. Команда `fg %top` повернула його на передній план.

Процес знову призупинено `Ctrl + Z`. Потім командою `bg %top` його виконання відновлено у фоновому режимі. `jobs` підтвердила статус "Running".

> **[СКРІНШОТ 9: Вивід `jobs`, що показує `top` у статусі "Running" після `bg`]**  
> ![Скріншот 9](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/9.png)

На завершення фоновий процес `top` було завершено командою `kill %top`. Для підтвердження виконано `jobs` (порожній список) та `ps aux | grep top` (процес відсутній).

> **[СКРІНШОТ 10: Вивід команд `jobs` та `ps aux | grep top` після завершення процесу]**  
> ![Скріншот 10](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson4/img/10.png)

---

## Контрольні запитання

1.  **Яке призначення директорії /proc в системах Linux. Яку інформацію вона зберігає?**
    *   Директорія `/proc` (procfs) є віртуальною файловою системою, яка надає інтерфейс для доступу до структур даних ядра Linux. Вона не зберігає дані на жорсткому диску, а створюється динамічно в пам'яті. Вона зберігає інформацію про кожен запущений процес (у каталогах з іменами, що відповідають їхнім PID), системну інформацію (CPU, пам'ять, версія ядра), параметри мережі та апаратного забезпечення. Читання та запис у деякі файли `/proc` дозволяє не тільки отримувати інформацію, але й змінювати параметри ядра "на льоту".

2.  **Як серед будь-яких трьох процесів динамічно визначати, який з них в поточний момент часу використовує найбільший обсяг пам'яті? Який відсоток пам’яті він споживає від загального обсягу?**
    *   Для динамічного визначення найкраще використати команду `top` або `htop`. У `top` потрібно натиснути `Shift + f`, вибрати стовпець `%MEM` для сортування та натиснути `s`. Процес, який споживає найбільше пам'яті, буде на самому верху списку, а у відповідному стовпці `%MEM` буде показано відсоток фізичної пам'яті (RES), яку він використовує відносно загального об'єму.

3.  **Як отримати ієрархію батьківських процесів в системах Linux? Наведіть її структуру та охарактеризуйте.**
    *   Ієрархію батьківських процесів можна отримати за допомогою команди `ps` з параметром `--forest`: `ps -ef --forest`, або `pstree`. Структура має деревоподібний вигляд. Коренем цього дерева є процес `init` (або `systemd`), який має PID 1. Він запускається першим ядром і є предком для всіх інших процесів. Кожен новий процес (дочірній) створюється шляхом клонування існуючого (батьківського) процесу за допомогою системних викликів `fork()` та `exec()`. Це дозволяє відстежити, який процес запустив який.

4.  **Чим відрізняється команда top від ps?**
    *   **`ps`**: Це статична команда, яка робить "знімок" стану процесів на момент її виконання. Вона виводить дані один раз і завершує роботу.
    *   **`top`**: Це інтерактивна динамічна програма, яка оновлює інформацію про процеси в реальному часі з певним інтервалом. Вона також надає інформацію про загальний стан системи (навантаження, використання пам'яті) та дозволяє керувати процесами (наприклад, змінювати їхній пріоритет або завершувати їх) безпосередньо зі свого інтерфейсу.

5.  **Які додаткові можливості реалізує htop в порівнянні з top?**
    *   `htop` є більш сучасною та зручною альтернативою `top`. Його додаткові можливості включають:
        *   Кольорове оформлення та більш інтуїтивний інтерфейс.
        *   Можливість прокручувати список процесів вертикально та горизонтально за допомогою клавіш зі стрілками.
        *   Можливість використовувати мишу для вибору процесів, натискання кнопок (наприклад, F9 для kill).
        *   Відображення процесів у вигляді дерева за замовчуванням (можна ввімкнути).
        *   Можливість надсилати сигнали процесам без необхідності знати PID або номер сигналу, просто вибравши його з меню.
        *   Більш гнучкі можливості для вибору відображуваних стовпців.

6.  **Опишіть компоненти вашої мобільної ОС для здійснення моніторингу запущених в системі процесів?**
    *   *(Відповідь залежить від ОС телефону. Наприклад, для Android)*
    *   У мобільній ОС Android (яка базується на ядрі Linux) моніторинг процесів здійснюється через вбудований `Activity Manager` та `Process Stats`. У меню "Параметри розробника" є розділ "Статистика процесів", який показує, які процеси запущені та скільки пам'яті вони споживають. Також ОС автоматично відстежує стан процесів і може завершувати їх для звільнення пам'яті за допомогою Low Memory Killer (на основі оцінки важливості процесу).

7.  **Чи підтримує Ваша мобільна ОС термінальне керування роботою процесів, опишіть як саме.**
    *   *(Відповідь залежить від ОС телефону. Наприклад, для Android)*
    *   Так, підтримує. На Android можна встановити емулятор терміналу (наприклад, Termux). Після встановлення стають доступними багато стандартних Linux-команд. Через нього можна використовувати `ps`, `top` (`toybox top`), `kill` для перегляду та керування процесами, але це зазвичай вимагає наявності root-прав для впливу на системні або чужі процеси.

8.  **Чи можливо поставити сторонні програмні засоби, що дозволяють організувати управління та моніторинг роботою процесів у Вашому мобільному телефоні. Коротко опишіть їх.**
    *   Так, існує багато сторонніх засобів. Для Android це, наприклад:
        *   **System Monitor**: Відображає інформацію про використання CPU, пам'яті, мережі, а також список запущених процесів, дозволяючи їх завершувати.
        *   **OS Monitor**: Потужний інструмент, який показує процеси, мережеві з'єднання (хто з якими IP-адресами спілкується), логи системи та інформацію про дозволи додатків.
        *   **Greenify**: Дозволяє "присипляти" певні додатки, коли вони не використовуються, щоб запобігти їхній фоновій активності та економити заряд батареї.
        *   **Вбудовані засоби**: Багато виробників (Samsung, Xiaomi) мають власні менеджери додатків у налаштуваннях, де можна переглядати запущені сервіси та примусово їх зупиняти.

---

## Conclusion

Through this laboratory work, we gained significant practical experience in managing processes within the Linux environment using the Bash shell. We successfully explored the fundamental mechanisms of the operating system by interacting with the /proc virtual file system and analyzing the lifecycle of various tasks.

The transition from using ps for static snapshots to top for dynamic monitoring allowed us to understand how the system allocates CPU and memory resources in real time. We also mastered the essential skills of job control, specifically learning how to move processes between the foreground and background using fg and bg commands, and how to suspend them using SIGTSTP signals.

Furthermore, the work demonstrated the importance of signals in process management. By using the kill command and keyboard interrupts like Ctrl+C, we practiced the controlled termination of tasks. Understanding the parent-child relationship and the process hierarchy, as visualized through the --forest flag, provided a clear picture of how the OS kernel organizes execution from the initial systemd process downward.

Ultimately, these exercises solidified our ability to monitor system stability and manage system resources efficiently, which is a core competency for any systems administrator or software developer working in a Unix-like environment.