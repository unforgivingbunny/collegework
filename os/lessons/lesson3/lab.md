# Лабораторна робота №3
**Дисципліна:** Операційні системи  
**Тема:** “Знайомство з базовими командами CLI-режиму в Linux”  
**Виконали:** Глядченко, Козуб 

---

## Мета роботи

Знайомство з базовими командами CLI-режиму в Linux.
Знайомство з базовими текстовими командами в термінальному режимі роботи в різних ОС.

---

## Vocabulary of English Terms

| Term | Definition/Explanation |
| :--- | :--- |
| **Shell** | A command-line interpreter that provides an interface between the user and the operating system. |
| **Command Line** | A text-based interface where users type commands to perform operations. |
| **CLI** | Command Line Interface. A method of interacting with a computer by typing text commands. |
| **Prompt** | A sequence of characters (e.g., `user@host:~$`) displayed by the shell to indicate it is ready to accept commands. |
| **Command** | A software program or built-in function that performs a specific action when executed. |
| **Argument** | An item of information provided to a command, such as a filename, directory, or text string, that the command acts upon. |
| **Variable** | A named storage location in memory that holds a value, which can be text or a number. |
| **Alias** | A custom shortcut or nickname created for a longer command or sequence of commands to save typing. |
| **Scripting** | The process of writing and executing a series of commands stored in a file (a script) for automation. |
| **Built-in command** | A command that is integrated directly into the shell itself and does not exist as an external file in the filesystem (e.g., `cd`, `echo`, `export`). |
| **External command** | A command that exists as a separate executable file in the filesystem (e.g., `ls`, `cp`, `man`). |
| **History** | A feature of the shell that keeps a list of previously executed commands, allowing for easy recall, editing, and re-execution. |
| **Manual page (man)** | A built-in documentation system accessed via the `man` command, providing detailed information about commands, system calls, file formats, and more. |

---

## Хід роботи

### Визначення понять

*   **Командний інтерпретатор (Command Interpreter):** Це програма, яка отримує рядки тексту (команди), введені користувачем, аналізує їх і передає ядру операційної системи для виконання або виконує їх самостійно, якщо це вбудовані команди.
*   **Оболонка (Shell):** Синонім командного інтерпретатора в UNIX-подібних системах. Це користувацький інтерфейс до операційної системи. Найпоширеніша оболонка в Linux — Bash (Bourne Again SHell).
*   **Команда (Command):** Це ім'я програми, вбудованої функції оболонки, псевдоніма або скрипта, яке користувач вводить у командному рядку для виконання певних дій.

### Відповіді на питання

**1. Яку базову інформацію надає рядок запрошення (prompt)?**
Рядок запрошення надає контекстну інформацію про поточний сеанс роботи. У типовому форматі `sysadmin@localhost:~$` міститься:
*   Ім'я користувача (`sysadmin`).
*   Ім'я системи (хоста) (`localhost`).
*   Поточний робочий каталог (`~`, що означає домашню директорію користувача).
*   Символ запрошення (`$` для звичайного користувача, `#` для root).

**2. Для чого команді потрібні параметри та аргументи?**
*   **Параметри (Options)** потрібні для зміни стандартної поведінки команди. Вони дозволяють налаштувати вивід, формат або дію команди (наприклад, `-l` для детального списку замість простого).
*   **Аргументи (Arguments)** вказують команді, на чому саме слід виконувати дію. Вони є "об'єктами" впливу команди (наприклад, ім'я файлу для відкриття, шлях до каталогу для перегляду).

**3. Яке призначення команд `ls`, які параметри та аргументи вона може мати? Наведіть 3 приклади.**
Команда `ls` призначена для виведення списку вмісту каталогів.
*   **Приклад 1:** `ls` - вивести список файлів та папок у поточному каталозі.
*   **Приклад 2:** `ls -l /home` - вивести детальну інформацію (параметр `-l`) про вміст каталогу `/home` (аргумент).
*   **Приклад 3:** `ls -a` - вивести весь вміст поточного каталогу, включаючи приховані файли (параметр `-a`).

**4. Яким чином можна використати історію команд, які переваги це надає?**
Історію команд можна використовувати за допомогою:
*   Клавш "вгору/вниз" для навігації по раніше введених командах.
*   Команди `history` для виведення всього списку.
*   Комбінації `Ctrl+R` для пошуку по історії.
*   Виконання команди з історії за номером: `!номер`.
*   **Переваги:** Економія часу, уникнення помилок при повторному введенні складних команд, можливість проаналізувати попередні дії.

**5. Яке призначення команди `echo`?**
Команда `echo` використовується для виведення рядка тексту або значення змінної на стандартний вивід (екран).

**6. Охарактеризуйте поняття змінної в оболонці Bash, які типи змінних вона підтримує?**
Змінна в Bash — це іменована комірка пам'яті, яка зберігає певне значення (найчастіше рядок тексту). Bash підтримує два основні типи змінних:
*   **Локальні змінні (Local variables):** Доступні лише в поточному екземплярі оболонки.
*   **Змінні оточення (Environment variables):** Успадковуються всіма дочірніми процесами, запущеними з даної оболонки.

**7. Яке призначення команд `env`, `export` та `unset`?**
*   **`env`:** Використовується для перегляду всіх поточних змінних оточення або для запуску програми в модифікованому оточенні.
*   **`export`:** Робить локальну змінну змінною оточення, роблячи її доступною для дочірніх процесів.
*   **`unset`:** Видаляє змінну або функцію оболонки.

**8. Які команди для отримання довідки по командам в терміналі ви знаєте?**
*   **`man команда`:** Відкриває детальний посібник (manual page) з описом, параметрами, прикладами.
*   **`команда --help`** або **`команда -h`:** Виводить коротку довідку з використанням команди.
*   **`info команда`:** Відкриває довідку в альтернативному форматі (info pages).
*   **`whatis команда`:** Виводить однорядковий опис команди.

---

### 1. Таблиця для опису команд

| Назва команди | Її призначення та функціональність |
| :--- | :--- |
| `ls` | Виводить інформацію про каталоги та файли. За замовчуванням (без аргументів) відображає вміст поточного каталогу. |
| `ls -l` | Дозволяє відобразити інформацію про файли в поточному каталозі у довгому форматі (права доступу, власник, розмір, дата модифікації). |
| `ls -l /tmp` | Дозволяє відобразити детальну інформацію про файли саме в каталозі `/tmp`. |
| `ls -a` | Відображає всі файли, включно з прихованими (ті, що починаються з крапки `.`). |
| `echo` | Виводить текст або значення змінних на стандартний пристрій виведення (на екран термінала). Наприклад: `echo "Hello World"`. |
| `echo $USER` | Виводить значення системної змінної `USER` (ім'я користувача, який зараз працює в системі). |
| `history` | Відображає пронумерований список раніше введених користувачем команд (історію команд). |
| `type` | Визначає та виводить інформацію про тип команди (наприклад, чи є вона вбудованою командою оболонки, зовнішнім файлом, псевдонімом або функцією). |
| `type cd` | Покаже, що `cd` є вбудованою командою оболонки. |
| `env` | Виводить список усіх поточних змінних середовища та їхні значення. |
| `export` | Використовується для створення або експорту змінної середовища, щоб вона стала доступною для дочірніх процесів та інших програм. Наприклад: `export MY_VAR="text"`. |
| `unset` | Видаляє раніше створену змінну. Наприклад: `unset MY_VAR`. |
| `man` | Відкриває сторінку посібника для вказаної команди з детальним описом синтаксису, параметрів та прикладів. Наприклад: `man ls`. |
| `info` | Відкриває документацію у форматі GNU Info. Часто містить більш розгорнуту та структуровану за розділами інформацію, ніж звичайні man-сторінки. |
| `command --help` | Багато команд (наприклад, `ls --help`) підтримують цей параметр для швидкого виведення короткої довідки щодо використання та доступних опцій прямо в термінал. |
| `whatis` | Шукає вказане слово в базі даних man-сторінок і виводить короткий опис команди. Наприклад: `whatis ls`. |
| `apropos` | Виконує пошук за ключовим словом в іменах та описах усіх man-сторінок. |
| `command1 ; command2` | Дозволяє виконати кілька команд послідовно в одному рядку. |
| `command1 && command2` | Виконає другу команду лише в тому випадку, якщо перша завершилась успішно. |

---

### 2.2 Робота в терміналі (закріплення практичних навичок)

#### 2.2.1. Робота зі змінними (Variables) та псевдонімами (Aliases)

**Мета:** Навчитися створювати змінні для зберігання даних та створювати короткі псевдоніми для довгих команд.

1.  **Створення змінних:**
    ```bash
    var_name1="Олег"
    var_name2="Макар"
    var_name3="Женя"
    ```
    *Очікуваний результат: команди не виводять нічого на екран, просто створюють змінні.*

2.  **Виведення імен за допомогою `echo`:**
    ```bash
    echo $var_name1 $var_name2 $var_name3
    ```

    *Скріншот: 2.2.1_echo_vars.png*
![2.2.1_echo_vars](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.1_echo_vars.png)

3.  **Створення псевдонімів:**
    ```bash
    alias mycal1='cal 2007'
    alias mycal2='cal 2008'
    alias mycal3='cal 2007'
    ```

4.  **Перевірка роботи псевдонімів:**
    ```bash
    mycal1
    mycal2
    mycal3
    ```

    *Скріншот: 2.2.1_aliases.png*
![2.2.1_aliases](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.1_aliases.png)

5.  **Перегляд усіх псевдонімів:**
    ```bash
    alias
    ```

---

#### 2.2.2. Робота з функціями (Functions)

**Мета:** Навчитися створювати просту функцію, яка виконує послідовність дій.

1.  **Створення функції `students_report`:**
    ```bash
    students_report () {
        echo "Імена студентів:"
        echo "$var_name1"
        echo "$var_name2"
        echo "$var_name3"
        echo "Роки народження:"
        echo "2007"
        echo "2008"
        echo "2007"
    }
    ```
    *Скріншот: 2.2.2_function_create.png*

![2.2.2_function_create](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.2_function_create.png)

2.  **Виклик функції:**
    ```bash
    students_report
    ```
    
    *Скріншот: 2.2.2_function_call.png*

![2.2.2_function_call](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.2_function_call.png)

---

#### 2.2.3. Робота з лапками (Quoting)

**Мета:** Зрозуміти різницю між одинарними (`'`), подвійними (`"`) лапками та виконанням команд.

1.  **Виведення речення з назвами змінних та їх вмістом:**
    Тут ми використовуємо `\$`, щоб вивести символ долара, а не підставляти значення змінної. Одинарні лапки всередині подвійних дозволяють виділити частину тексту.
    ```bash
    echo "'We create such variables as' \$var_name1, \$var_name2, \$var_name3, 'which stored our names' $var_name1, $var_name2, $var_name3"
    ```
    *Скріншот: 2.2.3_quoting_1.png*
![2.2.3_quoting_1](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.3_quoting_1.png)

2.  **Виведення речення з назвами псевдонімів та результатом їх роботи:**
    ```bash
    echo "'We create such Aliases as' mycal1, mycal2, mycal3, 'which can show our calendars:' $(mycal1 | head -1), $(mycal2 | head -1), $(mycal3 | head -1)"
    ```
    *Примітка: `| head -1` бере лише перший рядок виводу (назву року), щоб ВДРУГЕ не захаращувати термінал усім календарем. :)*

    *Скріншот: 2.2.3_quoting_2.png*
![2.2.3_quoting_2](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.3_quoting_2.png)

---

#### 2.2.4. Робота з інструкціями керування (Control Statements)

**Мета:** Навчитися виконувати декілька команд в одному рядку за допомогою крапки з комою `;`.

1.  **Виконання завдань 2.1 та 2.2 одним рядком:**
    Цей рядок створить змінні, виведе їх, а потім виконає дії, аналогічні функції `students_report`. Крапка з комою розділяє окремі команди. Весь цей довгий рядок копіюється та вставляється в термінал як одна дія.
    ```bash
    var_name1=Олег; var_name2=Макар; var_name3=Женя; echo "--- Завдання 2.1 ---"; echo "Імена студентів:"; echo $var_name1 $var_name2 $var_name3; echo "--- Завдання 2.2 ---"; echo "Імена студентів:"; echo "$var_name1"; echo "$var_name2"; echo "$var_name3"; echo "Роки народження:"; echo "2007"; echo "2008"; echo "2007"
    ```

    *Скріншот: 2.2.4_control_statements.png*
![2.2.4_control_statements](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.4_control_statements.png)

---

#### 2.2.5. Робота з командами довідки (Man Pages)

**Мета:** Навчитися користуватися вбудованою документацією та знаходити різні параметри команд.

1.  **Отримання довідки для команди `uname`:**
    ```bash
    man uname
    ```
    *Скріншот: 2.2.5_man_uname.png*
![2.2.5_man_uname](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.5_man_uname.png)

2.  **5 різних варіантів виводу команди `uname`:**
    ```bash
    uname
    uname -n
    uname -r
    uname -m
    uname -a
    ```

    *Скріншот: 2.2.5_uname_examples.png*
![2.2.5_uname_examples](https://raw.githubusercontent.com/unforgivingbunny/collegework/main/os/lessons/lesson3/img/2.2.5_uname_examples.png)

---

### Відповіді на контрольні запитання

**1. Які типи команд існують в оболонці Bash?**

В оболонці Bash існують чотири основні типи команд:

* **Вбудовані команди (Internal / Built-in):** Команди, які є частиною самої оболонки Bash (наприклад, `cd`, `echo`, `type`). Їх виконання відбувається дуже швидко.
* **Зовнішні команди (External):** Окремі виконувані файли (програми), які зберігаються на диску (наприклад, `ls`, `cat`, `grep`).
* **Псевдоніми (Aliases):** Спеціальні скорочення для довших і складніших команд. Створюються користувачем для зручності.
* **Функції (Functions):** Набори команд, згруповані під одним ім'ям для виконання складніших завдань.

---

**2. Що таке змінні оточення? Які вони бувають. Як їх можна переглянути в терміналі?**

Змінні оточення (Environment Variables) — це іменовані об'єкти в пам'яті, які зберігають дані для налаштування середовища оболонки та передачі інформації програмам. 

* **Типи змінних:**
    * **Локальні змінні:** Доступні лише в поточному сеансі оболонки.
    * **Змінні середовища (Глобальні):** Доступні поточному сеансу оболонки та всім дочірнім процесам.
* **Як переглянути:**
    * Команда `env` або `printenv` виведе список усіх глобальних змінних.
    * Команда `echo $ІМ'Я_ЗМІННОЇ` виведе значення конкретної змінної.

---

**3. Опишіть змінну $PS1. Як в терміналі переглянути її вміст?**

Змінна `$PS1` визначає зовнішній вигляд основного рядка запрошення в терміналі (наприклад, `sysadmin@localhost:~$`). Вона містить спеціальні символи, які вказують Bash відображати ім'я користувача, ім'я комп'ютера, поточний каталог тощо.

---

**4. Як можна змінити значення змінної $PS1? Що при цьому відбудеться в рядку запрошенні в bash. Як змінити значення за замовчуванням?**

* **Як змінити на поточний сеанс:** Ввести в терміналі нове значення, наприклад: `PS1="MyPrompt> "`.
* **Що відбудеться:** Рядок запрошення миттєво зміниться на вказаний текст. Це діятиме лише до закриття поточного вікна термінала.
* **Як змінити за замовчуванням (назавжди):** Необхідно додати рядок з експортом нової змінної у конфігураційний файл вашого профілю - зазвичай це файл `.bashrc` (або `.bash_profile`), який знаходиться у вашому домашньому каталозі.

---

**5. Для чого використовують лапки в оболонці Bash?**

Лапки використовуються для того, щоб сказати оболонці Bash трактувати текст всередині них як єдине ціле або ігнорувати спеціальне значення певних символів.

* **Подвійні лапки `""`**: Зберігають значення більшості символів, але дозволяють використовувати змінні (наприклад, `echo "Привіт, $USER"` виведе ім'я).
* **Одинарні лапки `''`**: Ігнорують усі спеціальні символи (наприклад, `echo 'Привіт, $USER'` виведе рівно текст `Привіт, $USER`).
* **Зворотні лапки ` \` \` `**: Використовуються для підстановки команд (результат виконання команди всередині лапок підставляється в іншу команду).

---

**6. Для чого використовують інструкції керування, які їх види Ви знаєте?**

Інструкції керування (Control statements) дозволяють виконувати кілька команд в одному рядку або створювати логічні умови для їх виконання.

* **Крапка з комою (`;`)**: Послідовне виконання. Команди виконуються одна за одною незалежно від результату попередньої.
* **Подвійний амперсанд (`&&`)**: Логічне "І". Друга команда виконається **тільки якщо** перша завершилась успішно.
* **Подвійний пайп (`||`)**: Логічне "АБО". Друга команда виконається **тільки якщо** перша завершилась із помилкою.

---

**7. В чому різниця якщо в кінці рядку запрошення bash стоїть символ $ чи #?**

Ці символи є індикаторами прав доступу поточного користувача:

* Символ **`$`** означає, що ви працюєте як звичайний користувач зі стандартними (обмеженими) правами доступу.
* Символ **`#`** означає, що ви працюєте від імені суперкористувача (root / адміністратора) і маєте повний контроль над системою.

---

**8. Яке призначення команд whereis та locate? Яка між ними відмінність?**

Обидві команди використовуються для пошуку в системі, але працюють по-різному:

* **`whereis`**: Шукає лише специфічні файли, пов'язані з командами: сам виконуваний файл (бінарник), вихідний код команди та її сторінку довідки. Шукає в стандартних системних каталогах.
* **`locate`**: Здійснює швидкий пошук будь-яких файлів або каталогів за їхнім іменем (або частиною імені). Працює дуже швидко, оскільки шукає не на самому диску в реальному часі, а в попередньо згенерованій базі даних системи.
* **Відмінність**: `whereis` використовується конкретно для пошуку інформації про системні команди та програми, тоді як `locate` підходить для миттєвого пошуку будь-якого файлу на комп'ютері. Однак, `locate` може не знайти файли, які були створені щойно (до оновлення її бази даних).

---

### Conclusion

During this laboratory work, we successfully achieved the objective of getting acquainted with the basic Command Line Interface (CLI) commands in the Linux operating system. We gained a clear understanding of the Bash shell environment and the fundamental structure of Linux commands, including how to properly apply options and arguments to modify command behavior. 

Furthermore, we acquired practical skills in creating and managing variables and setting up command aliases to optimize our terminal workflow. We also learned how to correctly utilize different types of quoting to manipulate text, and explored the use of functions and control statements to execute multiple commands sequentially. 

Finally, we developed the essential skill of navigating internal documentation using built-in help tools to independently research command parameters. Overall, this lab provided a strong foundational understanding of the Linux CLI, transitioning our skills from basic command execution to more advanced shell interactions.